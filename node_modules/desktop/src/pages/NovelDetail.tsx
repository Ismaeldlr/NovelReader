import { useEffect, useRef, useState } from "react";
import { Link, useNavigate, useParams } from "react-router-dom";
import JSZip from "jszip";
import { initDb } from "../db/init";
import { EditNovelModal, EditNovelPayload } from "./modals/library_edit_novel";

type Novel = {
  id: number;
  title: string;
  author: string | null;
  description: string | null;
  cover_path: string | null;
  lang_original: string | null;
  status: string | null;
  slug: string | null;
  created_at: number;
  updated_at: number;
};

type ChapterRow = {
  id: number;
  seq: number;
  display_title: string | null;
};

export default function NovelDetail() {
  const { id } = useParams();
  const novelId = id;
  const [novel, setNovel] = useState<Novel | null>(null);
  const [chapters, setChapters] = useState<ChapterRow[]>([]);

  const [menuOpen, setMenuOpen] = useState<boolean>(false);
  const [addOpen, setAddOpen] = useState<boolean>(false); // NEW: add menu
  const [isEditOpen, setIsEditOpen] = useState(false);
  const [editing, setEditing] = useState<EditNovelPayload | null>(null);

  const did = useRef(false);
  const dbRef = useRef<any>(null);
  const txtRef = useRef<HTMLInputElement>(null);   // NEW
  const epubRef = useRef<HTMLInputElement>(null);  // NEW
  const nav = useNavigate();

  useEffect(() => {
    if (did.current) return;
    did.current = true;
    (async () => {
      const db = await initDb();
      dbRef.current = db;
      await loadNovel(db);
      await loadChapters(db);
    })().catch(e => console.error("DB error: " + String(e)));
  }, [novelId]);

  async function loadNovel(db: any) {
    if (!novelId) {
      setNovel(null);
      return;
    }
    const n = await db.select(
      `SELECT id, title, author, description, cover_path, lang_original, status, slug, created_at, updated_at
       FROM novels WHERE id = $1 LIMIT 1;`,
      [novelId]
    );
    setNovel(n[0] ?? null);
  }

  async function loadChapters(db: any) {
    const ch = await db.select(
      "SELECT id, seq, display_title FROM chapters WHERE novel_id = ? ORDER BY seq ASC;",
      [novelId]
    );
    setChapters(ch as ChapterRow[]);
  }

  function toggleMenu() { setMenuOpen(v => !v); }

  // ======= ADD MENU ACTIONS =======
  async function onAddEmpty() {
    if (!dbRef.current || !novelId) return;
    try {
      const nextSeq = await nextSeqForNovel();
      const name = `Chapter ${nextSeq}`;
      await dbRef.current.execute(
        "INSERT INTO chapters (novel_id, seq, volume, display_title) VALUES (?,?,?,?)",
        [novelId, nextSeq, null, name]
      );
      const chId = await getChapterIdBySeq(nextSeq);
      // create empty RAW variant
      const lang = novel?.lang_original ?? "en";
      await dbRef.current.execute(
        "INSERT INTO chapter_variants (chapter_id, variant_type, lang, title, content, source_url, provider, model_name, is_primary) VALUES (?,?,?,?,?,?,?,?,?)",
        [chId, "RAW", lang, name, "", null, null, null, 0]
      );
      await loadChapters(dbRef.current);
      nav(`/novel/${novelId}/chapter/${chId}`);
    } catch (e) {
      console.error("Create error: " + String(e));
    } finally {
      setAddOpen(false);
    }
  }

  function openTxtPicker() { txtRef.current?.click(); }
  function openEpubPicker() { epubRef.current?.click(); }

  async function onPickTxt(e: React.ChangeEvent<HTMLInputElement>) {
    const file = e.target.files?.[0];
    e.target.value = "";
    if (!file || !dbRef.current) return;

    try {
      const text = await readText(file);
      const name = file.name.replace(/\.[^.]+$/, "");
      const chId = await insertChapterWithContent(name, text);
      await loadChapters(dbRef.current);
      nav(`/novel/${novelId}/chapter/${chId}`);
    } catch (err) {
      console.error("Import error: " + String(err));
    } finally {
      setAddOpen(false);
    }
  }

  async function onPickEpub(e: React.ChangeEvent<HTMLInputElement>) {
    const file = e.target.files?.[0];
    e.target.value = "";
    if (!file || !dbRef.current) return;

    try {
      const { chapters: parsed } = await parseEpub(file);

      // Filter out “cover”, “toc”, empty-ish sections, etc.
      const clean = parsed.filter(ch => {
        const t = (ch.title || "").toLowerCase();
        const badTitle = /(cover|table of contents|contents|toc|copyright|title page)/i.test(t);
        const tooShort = (ch.text || "").replace(/\s+/g, " ").trim().length < 60; // heuristic
        return !badTitle && !tooShort;
      });

      if (!clean.length) {
        console.error("No readable chapters found in EPUB.");
        return;
      }

      const startSeq = await nextSeqForNovel();
      let seq = startSeq;
      const lang = novel?.lang_original ?? "en";

      for (const ch of clean) {
        const title = ch.title?.trim() || `Chapter ${seq}`;
        await dbRef.current.execute(
          "INSERT INTO chapters (novel_id, seq, volume, display_title) VALUES (?,?,?,?)",
          [novelId, seq, null, title]
        );
        const chId = await getChapterIdBySeq(seq);
        await dbRef.current.execute(
          "INSERT INTO chapter_variants (chapter_id, variant_type, lang, title, content, source_url, provider, model_name, is_primary) VALUES (?,?,?,?,?,?,?,?,?)",
          [chId, "RAW", lang, title, ch.text, null, "epub", null, 0]
        );
        seq++;
      }

      await loadChapters(dbRef.current);
      console.log(`Imported ${clean.length} chapter(s).`);
    } catch (err) {
      console.error("EPUB error: " + String(err));
    } finally {
      setAddOpen(false);
    }
  }


  // ======= DELETE / REMOVE =======
  async function deleteChapter(cid: number) {
    try {
      const db = dbRef.current ?? (await initDb());
      await db.execute("DELETE FROM chapters WHERE id = ?", [cid]);
      await loadChapters(db);
      console.log("Chapter deleted.");
    } catch (e) {
      console.error("Delete error: " + String(e));
    }
  }

  async function removeNovel(nid: number) {
    try {
      const db = dbRef.current ?? (await initDb());
      await db.execute("DELETE FROM novels WHERE id = ?", [nid]);
      console.log("Novel removed.");
      nav("/");
    } catch (e) {
      console.error("Remove error: " + String(e));
    }
  }

  // ======= EDIT MODAL =======
  function openEditModal(n: Novel) {
    setEditing({
      id: n.id,
      title: n.title,
      author: n.author ?? null,
      description: n.description ?? null,
      cover_path: n.cover_path ?? null,
      lang_original: n.lang_original ?? null,
      status: n.status ?? null
    });
    setIsEditOpen(true);
    setMenuOpen(false);
  }
  function closeEditModal() { setIsEditOpen(false); setEditing(null); }

  async function handleEditSubmit(data: EditNovelPayload) {
    const db = dbRef.current;
    if (!db) return;
    await db.execute(
      `UPDATE novels
       SET title = $1,
           author = $2,
           description = $3,
           cover_path = $4,
           lang_original = $5,
           status = $6,
           updated_at = CAST(strftime('%s','now') AS INTEGER)
       WHERE id = $7`,
      [
        data.title.trim(),
        data.author ?? null,
        data.description ?? null,
        data.cover_path ?? null,
        data.lang_original ?? null,
        data.status ?? null,
        data.id
      ]
    );
    await loadNovel(db);
  }

  // ======== EPUB IMPORT ========
  async function nextSeqForNovel() {
    const maxRow = await dbRef.current.select(
      "SELECT IFNULL(MAX(seq), 0) as m FROM chapters WHERE novel_id = ?;",
      [novelId]
    );
    return (maxRow[0]?.m ?? 0) + 1;
  }

  async function getChapterIdBySeq(seq: number) {
    const row = await dbRef.current.select(
      "SELECT id FROM chapters WHERE novel_id = ? AND seq = ? LIMIT 1;",
      [novelId, seq]
    );
    return row[0]?.id as number;
  }

  async function insertChapterWithContent(name: string, text: string) {
    const nextSeq = await nextSeqForNovel();
    await dbRef.current.execute(
      "INSERT INTO chapters (novel_id, seq, volume, display_title) VALUES (?,?,?,?)",
      [novelId, nextSeq, null, name]
    );
    const chId = await getChapterIdBySeq(nextSeq);
    const lang = novel?.lang_original ?? "en";
    await dbRef.current.execute(
      "INSERT INTO chapter_variants (chapter_id, variant_type, lang, title, content, source_url, provider, model_name, is_primary) VALUES (?,?,?,?,?,?,?,?,?)",
      [chId, "RAW", lang, name, text, null, null, null, 0]
    );
    return chId;
  }

  // ======= RENDER =======
  return (
    <div className="page">
      <header className="topbar">
        <h1>{novel ? novel.title : "Novel"}</h1>
        <div className="actions" style={{ position: "relative" }}>
          <button className="btn" onClick={() => setAddOpen(v => !v)}>
            + Add Chapter
          </button>

          {/* Add menu */}
          {addOpen && (
            <div
              style={{
                position: "absolute",
                top: "110%",
                right: 0,
                background: "rgba(0,0,0,0.8)",
                border: "1px solid rgba(255,255,255,0.12)",
                borderRadius: 10,
                padding: 6,
                display: "grid",
                gap: 6,
                zIndex: 3,
                minWidth: 200
              }}
            >
              <button className="library-menu-item" onClick={onAddEmpty}>Empty</button>
              <button className="library-menu-item" onClick={openTxtPicker}>Import TXT</button>
              <button className="library-menu-item" onClick={openEpubPicker}>Import EPUB</button>
            </div>
          )}

          {/* Hidden pickers */}
          <input
            ref={txtRef}
            type="file"
            accept=".txt,text/plain"
            style={{ display: "none" }}
            onChange={onPickTxt}
          />
          <input
            ref={epubRef}
            type="file"
            accept=".epub,application/epub+zip"
            style={{ display: "none" }}
            onChange={onPickEpub}
          />

          <Link to="/" className="btn btn-ghost">← Back</Link>
        </div>
      </header>

      {!novel ? (
        <div className="empty">
          <div className="empty-art" />
          <p>Novel not found.</p>
        </div>
      ) : (
        <>
          <section className="detail-hero">
            <div className="cover lg" aria-hidden="true">
              <div className="cover-shine" />
              <span className="cover-text">{initials(novel.title)}</span>

              <div className="library-menu-container">
                <button
                  className="library-menu-button"
                  onClick={toggleMenu}
                  aria-expanded={menuOpen}
                  aria-haspopup="menu"
                >
                  ⋮
                </button>
                {menuOpen && (
                  <div className="library-menu" role="menu">
                    <button
                      className="library-menu-item"
                      onClick={() => openEditModal(novel)}
                      role="menuitem"
                    >
                      Edit
                    </button>
                    <button
                      className="library-menu-item"
                      onClick={() => removeNovel(novel.id)}
                      role="menuitem"
                    >
                      Remove from Library
                    </button>
                  </div>
                )}
              </div>
            </div>

            <div className="detail-meta">
              <h2 className="title">{novel.title}</h2>
              <p className="author">{novel.author || "Unknown author"}</p>
              {novel.description && <p className="desc">{novel.description}</p>}
              <div className="kv">
                <span>Original Lang:</span><b>{novel.lang_original || "—"}</b>
                <span>Status:</span><b>{novel.status || "—"}</b>
                <span>Slug:</span><b>{novel.slug || "—"}</b>
              </div>
            </div>
          </section>

          <section className="chapters">
            <h3>Chapters</h3>
            {chapters.length === 0 ? (
              <div className="empty small">
                <p>No chapters yet.</p>
                <p className="empty-sub">Use “Add Chapter” → Empty / TXT / EPUB.</p>
              </div>
            ) : (
              <ul className="chapter-list">
                {chapters.map(c => (
                  <li key={c.id} className="chapter-item">
                    <Link
                      to={`/novel/${novelId}/chapter/${c.id}`}
                      className="chapter-link"
                    >
                      <span className="chip">#{c.seq}</span>
                      <span className="chapter-title">
                        {c.display_title || `Chapter ${c.seq}`}
                      </span>
                    </Link>
                    <button className="deleteButton" onClick={() => deleteChapter(c.id)}>
                      <svg viewBox="0 0 448 512" className="deleteIcon">
                        <path d="M135.2 17.7L128 32H32C14.3 32 0 46.3 0 64S14.3 96 32 96H416c17.7 0 
                          32-14.3 32-32s-14.3-32-32-32H320l-7.2-14.3C307.4 6.8 296.3 0 284.2 0H163.8c-12.1 0-23.2 
                          6.8-28.6 17.7zM416 128H32L53.2 467c1.6 25.3 22.6 45 47.9 45H346.9c25.3 0 
                          46.3-19.7 47.9-45L416 128z"/>
                      </svg>
                    </button>
                  </li>
                ))}
              </ul>
            )}
          </section>

          <EditNovelModal
            open={isEditOpen}
            initial={editing}
            onClose={closeEditModal}
            onSubmit={async (payload) => {
              await handleEditSubmit(payload);
              closeEditModal();
            }}
            statusOptions={[
              { value: "ongoing", label: "Ongoing" },
              { value: "completed", label: "Completed" },
              { value: "hiatus", label: "Hiatus" }
            ]}
          />
        </>
      )}
    </div>
  );
}

/* ===================== Helpers ===================== */
function initials(title: string) {
  const words = title.trim().split(/\s+/).slice(0, 2);
  return words.map(w => w[0]?.toUpperCase() ?? "").join("");
}

function readText(file: File): Promise<string> {
  return new Promise((res, rej) => {
    const fr = new FileReader();
    fr.onerror = () => rej(fr.error);
    fr.onload = () => res(String(fr.result ?? ""));
    fr.readAsText(file);
  });
}

function readArrayBuffer(file: File): Promise<ArrayBuffer> {
  return new Promise((res, rej) => {
    const fr = new FileReader();
    fr.onerror = () => rej(fr.error);
    fr.onload = () => res(fr.result as ArrayBuffer);
    fr.readAsArrayBuffer(file);
  });
}

type ParsedChapter = { href: string; title: string; text: string };

async function parseEpub(file: File): Promise<{ chapters: ParsedChapter[] }> {
  const zip = await JSZip.loadAsync(await readArrayBuffer(file));

  // 1) OPF path
  const container = await zip.file("META-INF/container.xml")?.async("text");
  if (!container) throw new Error("Invalid EPUB: missing META-INF/container.xml");

  const parser = new DOMParser();
  const cdoc = parser.parseFromString(container, "application/xml");
  const rootfile = cdoc.querySelector("rootfile")?.getAttribute("full-path");
  if (!rootfile) throw new Error("Invalid EPUB: missing rootfile path");

  // 2) OPF
  const opfText = await zip.file(rootfile)?.async("text");
  if (!opfText) throw new Error("Invalid EPUB: OPF not found");
  const opf = parser.parseFromString(opfText, "application/xml");

  // manifest + spine
  const manifest = new Map<string, { href: string; type: string; props: string }>();
  opf.querySelectorAll("manifest > item").forEach(it => {
    const id = it.getAttribute("id") || "";
    manifest.set(id, {
      href: it.getAttribute("href") || "",
      type: it.getAttribute("media-type") || "",
      props: it.getAttribute("properties") || ""
    });
  });

  const spineIds = Array.from(opf.querySelectorAll("spine > itemref"))
    .map(n => n.getAttribute("idref") || "")
    .filter(Boolean);

  const basePath = rootfile.split("/").slice(0, -1).join("/");

  const chapters: ParsedChapter[] = [];

  for (const id of spineIds) {
    const meta = manifest.get(id);
    if (!meta) continue;

    // Skip nav/NCX and non-html resources
    const isNav = /\bnav\b/i.test(meta.props);
    const isNcx = /application\/x-dtbncx\+xml/i.test(meta.type);
    const isHtml = /x?html/i.test(meta.type) || /\.x?html?$/i.test(meta.href);
    if (isNav || isNcx || !isHtml) continue;

    const path = resolvePath(basePath, meta.href);
    const htmlText = await zip.file(path)?.async("text");
    if (!htmlText) continue;

    // Preserve <br> as newlines before parsing
    const htmlWithBreaks = htmlText.replace(/<br\s*\/?>/gi, "\n");

    const doc = parser.parseFromString(htmlWithBreaks, "text/html");

    const title =
      doc.querySelector("h1,h2,h3,title")?.textContent?.trim() || "";

    // Robust plain text with paragraph breaks
    const text = htmlToText(doc);

    chapters.push({ href: meta.href, title, text });
  }

  return { chapters };
}

function htmlToText(doc: Document) {
  // Collect block elements and join with blank lines
  const blocks = doc.body.querySelectorAll(
    "h1,h2,h3,h4,h5,h6,p,li,blockquote,pre,div,section,article,figure"
  );
  const lines = Array.from(blocks)
    .map(el => (el.textContent || "").trim())
    .filter(Boolean);

  let text = lines.join("\n\n");

  // Collapse excessive blank lines & trim
  text = text.replace(/\n{3,}/g, "\n\n").trim();

  return text;
}

function resolvePath(base: string, href: string) {
  if (!base) return href;
  const stack = base.split("/").filter(Boolean);
  for (const seg of href.split("/")) {
    if (!seg || seg === ".") continue;
    if (seg === "..") stack.pop();
    else stack.push(seg);
  }
  return stack.join("/");
}